<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>高级前端开发工程师面试题</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
    <div class="container">
        <div>
            <h2 class="title_1">谈谈Cookie的弊端</h2>
            <div class="part_1">
                <h3>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。</h3>
                <p>
                    <span>优点：极高的扩展性和可用性</span>
                    <ol>
                        <li>通过良好的编程，控制保存在cookie中的session对象的大小。</li>
                        <li>通过加密和安全传输技术（SSL），减少cookie被破解的可能性。</li>
                        <li>只在cookie中存放不敏感数据，即使被盗也不会有重大损失。</li>
                        <li>.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</li>
                    </ol>
                </p>
                <p>
                    <span>缺点：</span>
                    <ol>
                        <li>Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。</li>
                        <li>安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</li>
                        <li>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_2">浏览器本地存储</h2>
            <div class="part_2">
                <p>
                    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。 html5中的WebStorage包括了两种存储方式：sessionStorage和localStorage。 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_3">web storage和cookie的区别</h2>
            <div class="part_3">
                <p>
                    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的UserData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等
                </p>
            </div>
        </div>
        <div>
            <h1>CSS 相关问题</h1>
        </div>
        <div>
            <h2 class="title_4">display:none和visibility:hidden的区别？</h2>
            <div class="part_4">
                <p>
                    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢， 就当他从来不存在。
                </p>
                <p>
                    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_5">CSS中 link 和@import 的区别是？</h2>
            <div class="part_5">
                <ol>
                    <li>link属于HTML标签，而@import是CSS提供的;</li>
                    <li> 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</li>
                    <li>import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</li>
                    <li>link方式的样式的权重 高于@import的权重.</li>
                </ol>
            </div>
        </div>
        <div>
            <h2 class="title_6">display:none和visibility:hidden的区别？</h2>
            <div class="part_6">
                <p>
                    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢， 就当他从来不存在。
                </p>
                <p>
                    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_7">position的absolute与fixed共同点与不同点</h2>
            <div class="part_7">
                <p>
                    <span>共同点：</span>
                    <ol>
                        <li>改变行内元素的呈现方式，display被置为block；</li>
                        <li>让元素脱离普通流，不占据空间；</li>
                        <li>默认会覆盖到非定位元素上</li>
                    </ol>
                </p>
                <p>
                    不同点： absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_8">介绍一下CSS的盒子模型？</h2>
            <div class="part_8">
                <ol>
                    <li>有两种: IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading;</li>
                    <li>盒模型: 从内到外为内容(content)、填充(padding)、边界(margin)、 边框(border).</li>
                </ol>
            </div>
        </div>
        <div>
            <h2 class="title_9">CSS 选择器有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h2>
            <div class="part_9">
                <p>
                    <span>CSS 选择符有：</span>
                    <ol>
                        <li>id选择器（ # myid）</li>
                        <li>类选择器（.myclassname）</li>
                        <li>标签选择器（div, h1, p）</li>
                        <li>相邻选择器（h1 + p）</li>
                        <li>子选择器（ul > li）</li>
                        <li>后代选择器（li a）</li>
                        <li>通配符选择器（ * ）</li>
                        <li>属性选择器（a[rel = "external"]）</li>
                        <li>伪类选择器（a: hover, li:nth-child）</li>
                    </ol>
                </p>
                <p><span>能否继承的属性如下介绍</span>
                    <ol>
                        <li> 可继承的样式： font-size font-family color, text-indent;</li>
                        <li>不可继承的样式：border padding margin width height ;</li>
                        <li> 优先级就近原则，同权重情况下样式定义最近者为准;
                        </li>
                        <li>载入样式以最后载入的定位为准;</li>
                    </ol>
                </p>
                <p>
                    <span>优先级为:</span>
                    <ol>
                        <li>!important > id > class > tag</li>
                        <li>important 比 内联优先级高,但内联比 id 要高</li>
                    </ol>
                </p>
                <p>
                    <span>CSS3新增伪类举例：</span>
                    <ol>
                        <li>p:first-of-type 选择属于其父元素的首个
                            <\p> 元素的每个
                                <\p> 元素。</li>
                        <li>p:last-of-type 选择属于其父元素的最后
                            <\p> 元素的每个
                                <\p> 元素。</li>
                        <li>p:only-of-type 选择属于其父元素唯一的
                            <\p> 元素的每个
                                <\p> 元素。</li>
                        <li>p:only-child 选择属于其父元素的唯一子元素的每个
                            <\p> 元素。</li>
                        <li>p:nth-child(2) 选择属于其父元素的第二个子元素的每个
                            <\p> 元素。</li>
                        <li>:enabled :disabled 控制表单控件的禁用状态。</li>
                        <li>:checked 单选框或复选框被选中。</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_10">列出display的值，说明他们的作用。position的值， relative和absolute分别是相对于谁进行定位的？</h2>
            <div class="part_10">
                <p>
                    <span>display的值主要有</span>
                    <ol>
                        <li> block 象块类型元素一样显示。</li>
                        <li>inline 缺省值。象行内元素类型一样显示。</li>
                        <li>inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。</li>
                        <li>list-item 象块类型元素一样显示，并添加样式列表标记。</li>
                    </ol>
                </p>
                <p>
                    <span>position定位：</span>
                    <ol>
                        <li>absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。</li>
                        <li>fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。
                        </li>
                        <li>relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。
                        </li>
                        <li>static 默认值。没有定位，元素出现在正常的流中</li>
                        <li>inherit 规定从父元素继承 position 属性的值。</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_11">CSS3有哪些新特性？</h2>
            <div class="part_11">
                <p>
                    CSS3实现圆角（border-radius），阴影（box-shadow）， 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是::selection. 媒体查询，多栏布局 border-image
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_12">为什么要初始化CSS样式。</h2>
            <div class="part_12">
                <p>
                    因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_13">解释下 CSS sprites，以及你要如何在页面或网站中使用它。</h2>
            <div class="part_13">
                <p>
                    CSS Sprites(雪碧图)其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制。
                </p>
            </div>
        </div>
        <h1>html部分</h1>
        <div>
            <h2 class="title_14">说说你对语义化的理解？</h2>
            <div class="part_14">
                <p>
                    <ol>
                        <li> 去掉或者丢失样式的时候能够让页面呈现出清晰的结构;</li>
                        <li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重;</li>
                        <li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页;</li>
                        <li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_15">Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h2>
            <div class="part_15">
                <p>
                    <ol>
                        <li>
                            <\!DOCTYPE> 声明位于文档中的最前面，处于
                                <\html> 标签之前。告知浏览器以何种模式来渲染文档。</li>
                        <li>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</li>
                        <li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</li>
                        <li>DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_16">HTML与XHTML---二者有什么区别</h2>
            <div class="part_16">
                <p>
                    <span>区别：</span>
                    <ol>
                        <li>所有的标记都必须要有一个相应的结束标记</li>
                        <li>所有标签的元素和属性的名字都必须使用小写</li>
                        <li>所有的XML标记都必须合理嵌套</li>
                        <li>所有的属性必须用引号""括起来</li>
                        <li>把所有
                            <和&特殊符号用编码表示</li>
                                <li>给所有属性赋一个值</li>
                                <li>不要在注释内容中使“--”</li>
                                <li>图片必须有说明文字</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_17">常见兼容性问题？</h2>
            <div class="part_17">
                <p>
                    <ol>
                        <li>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</li>
                        <li>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</li>
                        <li>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</li>
                        <li>渐进识别的方式，从总体中逐渐排除局部。
                            <ul>
                                <li>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。</li>
                                <li>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</li>
                                <li>css示例：</li>
                                <li>.bb{</li>
                                <li>background-color:#f1ee18;/*所有识别*/</li>
                                <li>.background-color:#00deff\9; /*IE6、7、8识别*/</li>
                                <li>+background-color:#a200ff;/*IE6、7识别*/</li>
                                <li>_background-color:#1e0bd1;/*IE6识别*/</li>
                                <li> }</li>
                            </ul>
                        </li>
                        <li>IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性. 解决方法:统一通过getAttribute()获取自定义属性.
                        </li>
                        <li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</li>
                        <li>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</li>
                        <li>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用[html5]</li>
                        <li>上下margin重合问题 ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。 解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。
                        </li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_18">解释下浮动和它的工作原理？清除浮动的技巧</h2>
            <div class="part_18">
                <h3>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</h3>
                <p>
                    <span>清除浮动的技巧</span>
                    <ol>
                        <li>使用空标签清除浮动。 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</li>
                        <li>使用overflow。 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。</li>
                        <li>使用after伪对象清除浮动。 该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意:该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_19">浮动元素引起的问题</h2>
            <div class="part_19">
                <p>
                    <span>浮动元素引起的问题：</span>
                    <ol>
                        <li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
                        <li>与浮动元素同级的非浮动元素会跟随其后</li>
                        <li>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="h21">IE 8以下版本的浏览器中的盒模型有什么不同</h2>
            <div class="part1">
                <p>
                    IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_20">DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</h2>
            <div class="part_20">
                <p>
                    <ol>
                        <li>
                            创建新节点
                            <ul>
                                <li>createDocumentFragment() //创建一个DOM片段</li>
                                <li> createElement() //创建一个具体的元素</li>
                                <li>createTextNode() //创建一个文本节点</li>
                            </ul>
                        </li>
                        <li>
                            添加、移除、替换、插入
                            <ul>
                                <li>appendChild()</li>
                                <li>removeChild()</li>
                                <li>replaceChild()</li>
                                <li>insertBefore() //在已有的子节点前插入一个新的子节点</li>
                            </ul>
                        </li>
                        <li>
                            查找
                            <ul>
                                <li>getElementsByTagName() //通过标签名称</li>
                                <li>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li>
                                <li>getElementById() //通过元素Id，唯一性</li>
                            </ul>
                        </li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_21">html5有哪些新特性、移除了那些元素？如何区分 HTML 和 HTML5？</h2>
            <div class="part_21">
                <p>
                    <span>新特性</span>
                    <ol>
                        <li>拖拽释放(Drag and drop) API</li>
                        <li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li>
                        <li>音频、视频API(audio,video)</li>
                        <li>画布(Canvas) API</li>
                        <li>地理(Geolocation) API</li>
                        <li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除</li>
                        <li>表单控件，calendar、date、time、email、url、search</li>
                        <li> 新的技术webworker, websocket, Geolocation</li>
                    </ol>
                </p>
                <p>
                    <span>移除的元素:</span>
                    <ol>
                        <li>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</li>
                        <li>对可用性产生负面影响的元素：frame，frameset，noframes</li>
                    </ol>
                </p>
                <p>
                    <span>区分 HTML 和 HTML5</span>
                    <ol>
                        <li> DOCTYPE声明</li>
                        <li>新增的结构元素</li>
                        <li>功能元素</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_22">iframe的优缺点？</h2>
            <div class="part_22">
                <p>
                    <span>优点:</span>
                    <ol>
                        <li>解决加载缓慢的第三方内容如图标和广告等的加载问题</li>
                        <li>Security sandbox</li>
                        <li>并行加载脚本</li>
                    </ol>
                </p>
                <p>
                    <span>缺点：</span>
                    <ol>
                        <li>iframe会阻塞主页面的Onload事件；</li>
                        <li>即时内容为空，加载也需要时间</li>
                        <li>没有语意</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_23">如何实现浏览器内多个标签页之间的通信?</h2>
            <div class="part_23">
                <p>
                    调用localstorge、cookies等本地存储方式
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_24">线程与进程的区别</h2>
            <div class="part_24">
                <p>
                    <ul>
                        <li>一个程序至少有一个进程,一个进程至少有一个线程.</li>
                        <li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
                        <li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
                        <li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
                        </li>
                        <li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>
                    </ul>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_25">如何对网站的文件和资源进行优化？</h2>
            <div class="part_25">
                <p>
                    <span>解决方案包括：</span>
                    <ol>
                        <li>文件合并</li>
                        <li>文件最小化/文件压缩</li>
                        <li> 使用 CDN 托管</li>
                        <li>缓存的使用（多个域名来提供缓存）</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_26">减少页面加载时间的方法。</h2>
            <div class="part_26">
                <p>
                    <ol>
                        <li>优化图片</li>
                        <li>图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）</li>
                        <li>优化CSS（压缩合并css，如margin-top,margin-left...)</li>
                        <li>网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）</li>
                        <li>标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）
                        </li>
                        <li>减少http请求（合并文件，合并图片）。</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_27">null和undefined的区别？</h2>
            <div class="part_27">
                <h3>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</h3>
                <p>
                    当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
                </p>
                <p>
                    <span>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</span>
                    <ol>
                        <li>变量被声明了，但没有赋值时，就等于undefined。</li>
                        <li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
                        <li>对象没有赋值的属性，该属性的值为undefined。</li>
                        <li>函数没有返回值时，默认返回undefined。</li>
                    </ol>
                    <span>null表示”没有对象”，即该处不应该有值。典型用法是：</span>
                    <ol>
                        <li> 作为函数的参数，表示该函数的参数不是对象。</li>
                        <li> 作为对象原型链的终点。</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_28">new操作符具体干了什么呢?</h2>
            <div class="part_28">
                <p>
                    <ol>
                        <li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>
                        <li>属性和方法被加入到 this 引用的对象中。</li>
                        <li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li>
                    </ol>
                    <ul>
                        <li>var obj = {};</li>
                        <li>obj.__proto__ = Base.prototype;</li>
                        <li>Base.call(obj);</li>
                    </ul>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_29"> JSON 的了解？</h2>
            <div class="part_29">
                <p>
                    JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_30">documen.write和 innerHTML的区别</h2>
            <div class="part_30">
                <p>
                    <ol>
                        <li>document.write只能重绘整个页面</li>
                        <li>innerHTML可以重绘页面的一部分</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_31">如何解决跨域问题?</h2>
            <div class="part_31">
                <p>具体参见：<a href="https://segmentfault.com/a/1190000000718840">详解js跨域问题</a></p>
                <p>
                    jsonp、 document.domain+iframe、window.name、window.postMessage、服务器上设置代理页面 jsonp的原理是动态插入script标签
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_32">.call() 和 .apply() 的区别和作用？</h2>
            <div class="part_32">
                <h3>动态改变某个类的某个方法的运行环境。</h3>
                <p>具体参见：<a href="https://segmentfault.com/a/1190000000660786#articleHeader15">JavaScript学习总结（四）function函数部分</a></p>
                <p>
                    apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。例如： function.apply(this,[1,2,3])
                </p>
                <p>
                    call()的第一个参数是上下文，后续是实例传入的参数序列，例如： function.call(this,1,2,3);
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_33">哪些操作会造成内存泄漏？</h2>
            <div class="part_33">
                <p>具体参见：<a href="https://segmentfault.com/a/1190000000687844">详解js变量、作用域及内存</a></p>
                <h3>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</h3>
                <p>
                    垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
                </p>
                <p>
                    setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_34">JavaScript中的作用域与变量声明提升？</h2>
            <div class="part_34">
                <p>具体参见：<a href="https://segmentfault.com/a/1190000000758184#articleHeader5">详解JavaScript函数模式</a></p>
                <p>
                    对于所有变量，无论在函数体的何处进行声明，都会在内部被提升到函数顶部。而对于函数通用适用，其原因在于函数只是分配给变量的对象。 提升，顾名思义，就是把下面的东西提到上面。在JS中，就是把定义在后面的东西（变量或函数）提升到前面中定义。
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_35">如何判断当前脚本运行在浏览器还是node环境中？</h2>
            <div class="part_35">
                <p>
                    通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_36">什么叫优雅降级和渐进增强？</h2>
            <div class="part_36">
                <p>
                    优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.
                </p>
                <p>
                    渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_37">对Node的优点和缺点提出了自己的看法？</h2>
            <div class="part_37">
                <p>
                    （优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求， 因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的， 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。
                </p>
                <p>
                    （缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变， 而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_38">你有哪些性能优化的方法？</h2>
            <div class="part_38">
                <p>
                    <ol>
                        <li>减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</li>
                        <li> 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
                        </li>
                        <li> 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</li>
                        <li>当需要设置的样式很多时设置className而不是直接操作style。</li>
                        <li>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</li>
                        <li>避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</li>
                        <li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_39">http状态码有那些？分别代表是什么意思？</h2>
            <div class="part_39">
                <p>
                    <ol>
                        <li>100-199 用于指定客户端应相应的某些动作。</li>
                        <li>200-299 用于表示请求成功</li>
                        <li>
                            300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。</li>
                        <li>
                            400-499 用于指出客户端的错误。</li>
                        <li>500-599 用于支持服务器错误。</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_40">一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2>
            <div class="part_40">
                <p>
                    <span>分为4个步骤：</span>
                    <ol>
                        <li>当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。</li>
                        <li>浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</li>
                        <li>一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。</li>
                        <li>此时，Web服务器提供资源服务，客户端开始下载资源。</li>
                    </ol>
                </p>
                <p>请求返回后，便进入了我们关注的前端模块 简单来说，浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSS Rule Tree，而javascript又可以根据DOM API操作DOM
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_41">ajax过程</h2>
            <div class="part_41">
                <p>
                    <ol>
                        <li>创建XMLHttpRequest对象,也就是创建一个异步调用对象.</li>
                        <li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</li>
                        <li>设置响应HTTP请求状态变化的函数.</li>
                        <li>发送HTTP请求.</li>
                        <li>获取异步调用返回的数据.</li>
                        <li>使用JavaScript和DOM实现局部刷新.</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_42">异步加载和延迟加载</h2>
            <div class="part_42">
                <p>
                    <ol>
                        <li>异步加载的方案： 动态插入script标签</li>
                        <li>通过ajax去获取js代码，然后通过eval执行</li>
                        <li>script标签上添加defer或者async属性</li>
                        <li>创建并插入iframe，让它异步执行js</li>
                        <li>延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。</li>
                    </ol>
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_43">javascript里面的继承怎么实现，如何避免原型链上面的对象共享</h2>
            <div class="part_43">
                <p>
                    用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_44">Flash、Ajax各自的优缺点，在使用中如何取舍？</h2>
            <div class="part_44">
                <p>Flash ajax对比
                    <ul>
                        <li> Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。</li>
                        <li> Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。</li>
                    </ul>
                </p>
                <p>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
                </p>
            </div>
        </div>
        <div>
            <h2 class="title_45">Node.js的适用场景？</h2>
            <div class="part_45">
                <p>高并发、聊天、实时消息推送
                </p>
            </div>
        </div>
    </div>
    <script type="text/javascript" src="js/jquery-3.1.1.min.js"></script>
    <script type="text/javascript" src="js/app.js"></script>
</body>

</html>
